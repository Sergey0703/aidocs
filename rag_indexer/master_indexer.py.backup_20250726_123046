#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Master RAG Document Indexer Controller
Manages processing of multiple subdirectories with Ollama restarts and organized logging
FIXED: Excludes doc_backups directory from processing as it's a service directory

This script orchestrates the indexing process across multiple subdirectories:
- Scans for subdirectories in the specified root path
- EXCLUDES doc_backups directory from processing (service directory)
- Processes each subdirectory independently using the main indexer
- Restarts Ollama between directories to prevent memory leaks
- Maintains organized logs with clear directory separation
- Provides comprehensive progress tracking and error handling

Usage:
    python master_indexer.py

Configuration:
    Set MASTER_DOCUMENTS_DIR in .env file or modify the default path below
    The script will process all subdirectories found in the specified path
    EXCEPT doc_backups directory which contains backup files
"""

import os
import sys
import time
import subprocess
from datetime import datetime
from pathlib import Path
from dotenv import load_dotenv


# FIXED: List of service directories to exclude from processing
EXCLUDED_DIRECTORIES = [
    'doc_backups',    # Backup directory for converted .doc files
    'logs',           # Log files directory
    'temp',           # Temporary files directory
    '.git',           # Git repository directory
    '__pycache__',    # Python cache directory
    '.vscode',        # VS Code settings
    '.idea',          # IntelliJ IDEA settings
    'node_modules',   # Node.js modules
    '.env'            # Environment files
]


def log_master_message(message, log_file_path="./logs/master_indexer.log"):
    """
    Log master indexer messages with timestamps
    
    Args:
        message: Message to log
        log_file_path: Path to master log file
    """
    timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    log_entry = f"[{timestamp}] {message}\n"
    
    try:
        # Ensure logs directory exists
        os.makedirs(os.path.dirname(log_file_path), exist_ok=True)
        
        with open(log_file_path, 'a', encoding='utf-8') as f:
            f.write(log_entry)
    except Exception as e:
        print(f"WARNING: Could not write to master log: {e}")
    
    # Also print to console
    print(f"[MASTER] {message}")


def is_excluded_directory(directory_path):
    """
    Check if directory should be excluded from processing
    FIXED: Added function to check against excluded directories list
    
    Args:
        directory_path: Path to directory to check
    
    Returns:
        tuple: (is_excluded, reason)
    """
    directory_name = os.path.basename(directory_path).lower()
    
    # Check against excluded directories list
    for excluded in EXCLUDED_DIRECTORIES:
        if directory_name == excluded.lower():
            return True, f"Service directory ({excluded})"
    
    # Additional checks
    if directory_name.startswith('.'):
        return True, "Hidden directory"
    
    if not os.access(directory_path, os.R_OK):
        return True, "No read permission"
    
    # Check if directory is empty
    try:
        if not any(os.scandir(directory_path)):
            return True, "Empty directory"
    except Exception:
        return True, "Cannot scan directory"
    
    return False, None


def restart_ollama_service():
    """
    Restart Ollama service to prevent memory leaks
    Includes proper wait time for service to fully restart
    """
    log_master_message("Restarting Ollama service to prevent memory leaks...")
    
    try:
        # Stop Ollama service
        stop_result = subprocess.run(
            ["sudo", "systemctl", "stop", "ollama"],
            capture_output=True,
            text=True,
            timeout=30
        )
        
        if stop_result.returncode != 0:
            log_master_message(f"WARNING: Ollama stop command returned code {stop_result.returncode}")
        else:
            log_master_message("Ollama service stopped successfully")
        
        # Wait a moment for clean shutdown
        time.sleep(3)
        
        # Start Ollama service
        start_result = subprocess.run(
            ["sudo", "systemctl", "start", "ollama"],
            capture_output=True,
            text=True,
            timeout=30
        )
        
        if start_result.returncode != 0:
            log_master_message(f"ERROR: Ollama start command failed with code {start_result.returncode}")
            return False
        else:
            log_master_message("Ollama service started successfully")
        
        # Wait for Ollama to fully initialize (10 seconds as requested)
        log_master_message("Waiting 10 seconds for Ollama to fully initialize...")
        time.sleep(10)
        
        # Verify Ollama is responding
        try:
            import requests
            response = requests.get("http://localhost:11434/api/tags", timeout=5)
            if response.status_code == 200:
                log_master_message("Ollama service is responding correctly")
                return True
            else:
                log_master_message(f"WARNING: Ollama responded with status {response.status_code}")
                return True  # Continue anyway
        except Exception as e:
            log_master_message(f"WARNING: Could not verify Ollama status: {e}")
            return True  # Continue anyway
        
    except subprocess.TimeoutExpired:
        log_master_message("ERROR: Ollama restart command timed out")
        return False
    except Exception as e:
        log_master_message(f"ERROR: Failed to restart Ollama: {e}")
        return False


def scan_subdirectories(root_path):
    """
    Scan for subdirectories in the specified root path
    FIXED: Excludes service directories like doc_backups from processing
    
    Args:
        root_path: Root directory to scan for subdirectories
    
    Returns:
        list: List of subdirectory paths sorted by name (excluding service directories)
    """
    valid_subdirectories = []
    excluded_subdirectories = []
    
    try:
        root_path_obj = Path(root_path)
        
        if not root_path_obj.exists():
            log_master_message(f"ERROR: Root path does not exist: {root_path}")
            return []
        
        if not root_path_obj.is_dir():
            log_master_message(f"ERROR: Root path is not a directory: {root_path}")
            return []
        
        # Find all subdirectories and filter out excluded ones
        for item in root_path_obj.iterdir():
            if item.is_dir():
                is_excluded, reason = is_excluded_directory(str(item))
                
                if is_excluded:
                    excluded_subdirectories.append((str(item), reason))
                    log_master_message(f"EXCLUDED: {item.name} - {reason}")
                else:
                    valid_subdirectories.append(str(item))
        
        # Sort valid subdirectories by name for consistent processing order
        valid_subdirectories.sort()
        
        log_master_message(f"Found {len(valid_subdirectories)} valid subdirectories in {root_path}")
        log_master_message(f"Excluded {len(excluded_subdirectories)} service/system directories")
        
        if valid_subdirectories:
            log_master_message("Valid directories for processing:")
            for i, subdir in enumerate(valid_subdirectories, 1):
                log_master_message(f"  {i}. {subdir}")
        
        if excluded_subdirectories:
            log_master_message("Excluded directories:")
            for subdir, reason in excluded_subdirectories:
                log_master_message(f"  - {os.path.basename(subdir)}: {reason}")
        
        return valid_subdirectories
        
    except Exception as e:
        log_master_message(f"ERROR: Failed to scan subdirectories: {e}")
        return []


def process_single_directory(directory_path, directory_index, total_directories):
    """
    Process a single directory using the main indexer
    
    Args:
        directory_path: Path to the directory to process
        directory_index: Current directory index (1-based)
        total_directories: Total number of directories to process
    
    Returns:
        bool: True if processing was successful, False otherwise
    """
    directory_name = os.path.basename(directory_path)
    
    # FIXED: Double-check that we're not processing excluded directories
    is_excluded, reason = is_excluded_directory(directory_path)
    if is_excluded:
        log_master_message(f"SKIPPING: {directory_name} - {reason} (double-check)")
        return True  # Return success to not count as failure
    
    log_master_message(f"")
    log_master_message(f"{'='*80}")
    log_master_message(f"PROCESSING DIRECTORY {directory_index}/{total_directories}: {directory_name}")
    log_master_message(f"Path: {directory_path}")
    log_master_message(f"{'='*80}")
    
    # Create a temporary .env override for this directory
    original_env = os.environ.get('DOCUMENTS_DIR', '')
    os.environ['DOCUMENTS_DIR'] = directory_path
    
    # Add directory info to failed files log for organization
    failed_files_log = "./logs/failed_files_details.log"
    try:
        os.makedirs("./logs", exist_ok=True)
        with open(failed_files_log, 'a', encoding='utf-8') as f:
            f.write(f"\n{'='*80}\n")
            f.write(f"PROCESSING DIRECTORY: {directory_path}\n")
            f.write(f"Started at: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n")
            f.write(f"Directory {directory_index} of {total_directories}\n")
            f.write(f"{'='*80}\n")
    except Exception as e:
        log_master_message(f"WARNING: Could not write directory header to failed files log: {e}")
    
    try:
        # Run the main indexer for this directory
        start_time = time.time()
        
        log_master_message(f"Launching indexer.py for directory: {directory_name}")
        
        result = subprocess.run(
            [sys.executable, "indexer.py"],
            cwd=os.getcwd(),
            env=os.environ.copy(),
            capture_output=False,  # Let output go to console
            text=True
        )
        
        processing_time = time.time() - start_time
        
        if result.returncode == 0:
            log_master_message(f"SUCCESS: Directory {directory_name} processed successfully in {processing_time:.1f}s")
            return True
        else:
            log_master_message(f"ERROR: Directory {directory_name} processing failed with return code {result.returncode}")
            return False
            
    except Exception as e:
        processing_time = time.time() - start_time if 'start_time' in locals() else 0
        log_master_message(f"ERROR: Exception while processing {directory_name}: {e}")
        return False
    
    finally:
        # Restore original environment
        if original_env:
            os.environ['DOCUMENTS_DIR'] = original_env
        elif 'DOCUMENTS_DIR' in os.environ:
            del os.environ['DOCUMENTS_DIR']


def create_final_summary(processed_directories, successful_directories, failed_directories, excluded_directories, total_time):
    """
    Create and log final processing summary
    FIXED: Include information about excluded directories
    
    Args:
        processed_directories: Total directories processed
        successful_directories: Number of successful directories
        failed_directories: Number of failed directories
        excluded_directories: Number of excluded directories
        total_time: Total processing time in seconds
    """
    log_master_message(f"")
    log_master_message(f"{'='*80}")
    log_master_message(f"MASTER INDEXER FINAL SUMMARY")
    log_master_message(f"{'='*80}")
    log_master_message(f"Total directories found: {processed_directories + excluded_directories}")
    log_master_message(f"Directories processed: {processed_directories}")
    log_master_message(f"Directories excluded: {excluded_directories} (service directories)")
    log_master_message(f"Successful directories: {successful_directories}")
    log_master_message(f"Failed directories: {failed_directories}")
    log_master_message(f"Success rate: {(successful_directories/processed_directories*100):.1f}%" if processed_directories > 0 else "0%")
    log_master_message(f"Total processing time: {total_time/60:.1f} minutes")
    log_master_message(f"Average time per directory: {total_time/processed_directories:.1f} seconds" if processed_directories > 0 else "N/A")
    
    # FIXED: Show excluded directories information
    if excluded_directories > 0:
        log_master_message(f"")
        log_master_message(f"EXCLUDED DIRECTORIES:")
        log_master_message(f"  {excluded_directories} service directories were automatically excluded:")
        log_master_message(f"  - doc_backups (backup files)")
        log_master_message(f"  - logs (log files)")
        log_master_message(f"  - temp, .git, __pycache__, etc.")
        log_master_message(f"  This prevents processing backup/system files")
    
    if failed_directories > 0:
        log_master_message(f"")
        log_master_message(f"WARNING: {failed_directories} directories failed to process")
        log_master_message(f"Check the master log for details on failed directories")
    else:
        log_master_message(f"")
        log_master_message(f"SUCCESS: All valid directories processed successfully!")
    
    log_master_message(f"")
    log_master_message(f"Detailed failed files information: ./logs/failed_files_details.log")
    log_master_message(f"Master processing log: ./logs/master_indexer.log")
    log_master_message(f"{'='*80}")


def main():
    """
    Main function to orchestrate multi-directory processing
    FIXED: Enhanced to exclude service directories
    """
    print("Master RAG Document Indexer Controller")
    print("=" * 50)
    print("ENHANCED: Automatically excludes service directories (doc_backups, logs, etc.)")
    print("=" * 50)
    
    # Load environment variables
    load_dotenv()
    
    # Get root directory from environment or use default
    root_directory = os.getenv("MASTER_DOCUMENTS_DIR", "./data/634/2025")
    
    log_master_message(f"Master indexer started")
    log_master_message(f"Root directory: {root_directory}")
    log_master_message(f"Excluded directories: {', '.join(EXCLUDED_DIRECTORIES)}")
    
    # Scan for valid subdirectories (excluding service directories)
    valid_subdirectories = scan_subdirectories(root_directory)
    
    if not valid_subdirectories:
        log_master_message(f"ERROR: No valid subdirectories found in {root_directory}")
        print("ERROR: No valid subdirectories found to process")
        print("All directories were either excluded (service directories) or inaccessible")
        sys.exit(1)
    
    # Initialize counters
    total_valid_directories = len(valid_subdirectories)
    successful_directories = 0
    failed_directories = 0
    
    # Calculate excluded directories for reporting
    try:
        all_dirs = [d for d in Path(root_directory).iterdir() if d.is_dir()]
        excluded_count = len(all_dirs) - total_valid_directories
    except:
        excluded_count = 0
    
    log_master_message(f"Starting processing of {total_valid_directories} valid directories")
    log_master_message(f"Excluded {excluded_count} service directories from processing")
    
    master_start_time = time.time()
    
    # Process each valid subdirectory
    for index, directory_path in enumerate(valid_subdirectories, 1):
        directory_name = os.path.basename(directory_path)
        
        try:
            # Process the directory
            success = process_single_directory(directory_path, index, total_valid_directories)
            
            if success:
                successful_directories += 1
                log_master_message(f"Directory {directory_name} completed successfully")
            else:
                failed_directories += 1
                log_master_message(f"Directory {directory_name} failed")
            
            # Restart Ollama between directories (except after the last one)
            if index < total_valid_directories:
                log_master_message(f"Preparing for next directory ({index + 1}/{total_valid_directories})")
                
                restart_success = restart_ollama_service()
                if not restart_success:
                    log_master_message(f"WARNING: Ollama restart failed, but continuing...")
                
                log_master_message(f"Ready to process next directory")
            
        except KeyboardInterrupt:
            log_master_message(f"INTERRUPTED: Master indexer interrupted by user")
            log_master_message(f"Processed {successful_directories} directories successfully before interruption")
            print("\nMaster indexer interrupted by user")
            sys.exit(1)
        
        except Exception as e:
            failed_directories += 1
            log_master_message(f"FATAL ERROR processing {directory_name}: {e}")
    
    # Calculate total time
    total_time = time.time() - master_start_time
    
    # Create final summary with exclusion information
    create_final_summary(
        total_valid_directories, 
        successful_directories, 
        failed_directories, 
        excluded_count, 
        total_time
    )
    
    # Print summary to console
    print(f"\nMaster indexer completed!")
    print(f"Total directories found: {total_valid_directories + excluded_count}")
    print(f"Valid directories processed: {total_valid_directories}")
    print(f"Service directories excluded: {excluded_count} (doc_backups, logs, etc.)")
    print(f"Successful: {successful_directories}")
    print(f"Failed: {failed_directories}")
    print(f"Total time: {total_time/60:.1f} minutes")
    print(f"Check ./logs/master_indexer.log for detailed information")
    
    # Exit with appropriate code
    if failed_directories > 0:
        sys.exit(1)
    else:
        sys.exit(0)


if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        print("\nMaster indexer interrupted by user")
        sys.exit(1)
    except Exception as e:
        print(f"FATAL ERROR in master indexer: {e}")
        sys.exit(1)